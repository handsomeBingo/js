<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style type="text/css">
div{ width:100px; height:100px; position:absolute; top:0; left:0; cursor:move; -webkit-user-select:none; overflow:hidden; background:gray;}
div img{ width:100px; height:100px; border:none;}
</style>
</head>

<body>
<div id="div1"><img src="img/6.png"></div>
<div id="div2" style="top:100px; left:100px; background:orange;"><img src="img/7.png"></div>
<div id="div3" style="left:200px; background:purple"><img src="img/12.png"></div>
<div id="div4" style="left:400px; background:pink;"><img src="img/13.png"></div>
</body>
</html>
<script src="event1.js"></script>
<script>
//面向对象的编程，主要是思想和管理，重管理轻逻辑
//相对于面向过程来说的。面向过程的编程是重逻辑的编程
//要确定一个主体对象（上下文），所以的行为（方法）和属性是依赖于这个主体的。
 
//addEventListener  ele.addEventListener
//attachEvent
//如果打算修改升级DOM元素的addEventListener方法，应该在那儿修改
//div-->HTMLDivElement-->HTMLElement-->Element-->node-->EventTarget-->Object
//EventTarget类是管理行为与行为之间的关系的 -->管理节点上的行为与其它行为对接的类就是这个EventTarget
//ele.addEventListener("click",fn1,false);

//如果只是用面向对象来完成一个单一的拖拽，除了麻烦，没有什么特点

//确定使用类或类上的方法的时候一个非常重要的原则：在类上的方法里，this关键字一定要指向当前类的实例；如果和事件绑定的原则冲突，则强制执行这里原则（一定用call或apply方法改变其this的指向，让其指向Drag类的实例）
function Drag(ele){//初始化实例的作用，把实例上要用到的一些私有属性或方法，在这准备好
	this.x=null;
	this.y=null;
	this.mx=null;
	this.my=null;
	//document.body.offsetParent
	//document.body.offsetparent;
	this.ele=ele;//通过参数把被拖拽的元素传进来，然后把它保存到实例的ele属性上，这样在其它的原型方法里就可以通过this.ele这个属性来操作被拖拽的元素了。一个方法的参数相当于这个方法的私有变量。
	/*
	//以下这种绑定方式会导致this.down方法里的this指向ele，就和我们规定的原则冲突了。
	on(ele,"mousedown",this.down);this.down();//这里的this.down方法并没有执行，所以down里没有this，只是通过this找到down方法的定义。这会儿，我们只需把this.down看成一个方法定义的地址既可
	张三.大舅.三姑.四姨夫.表妹.请客();//表妹前面所有的对象，只是找到表妹这个对象的途径。
	on(this.ele,"mousedown",this.down);
	this
	*/
	this.DOWN=processThis(this.down,this);
	/*
		//processThis返回值this.DOWN的原理如下：
	var that=this;
	this.DOWN=function(e){that.down.call(that,e);this}
	*/
	on(this.ele,"mousedown",this.DOWN);//this.DOWN在被mousedown事件触发执行的时候，它里的this是谁？
	//大DOWN里有this,小down里也有this，DOWN里的this由它被绑定给谁决定，但小down里的this已经被call给强制处理过了，所以小down里的this无论什么情况，都会是Drag类的实例
	//this.ele.addEventListener("mousedown",this.DOWN,false);
	this.MOVE=processThis(this.move,this);
	this.UP=processThis(this.up,this);
}
Drag.prototype.down=function(e){
	this.x=this.ele.offsetLeft;
	this.y=this.ele.offsetTop;
	this.mx=e.pageX;
	this.my=e.pageY;
	if(this.ele.setCapture){
		this.ele.setCapture();
		on(this.ele,"mousemove",this.MOVE);
		on(this.ele,"mouseup",this.UP);
	}else{
		on(document,"mousemove",this.MOVE);
		on(document,"mouseup",this.UP);
	}
	
	e.preventDefault();
}
Drag.prototype.move=function(e){
	this.ele.style.left=this.x+(e.pageX-this.mx)+"px";
	this.ele.style.top=this.y+(e.pageY-this.my)+"px";
}
Drag.prototype.up=function(e){
	if(this.ele.releaseCapture){
		off(this.ele,"mousemove",this.MOVE);
		off(this.ele,"mouseup",this.UP);
		this.ele.releaseCapture();		
	}else{
		off(document,"mousemove",this.MOVE);
		off(document,"mouseup",this.UP);
	}
}

var eles=document.getElementsByTagName("div");
for(var i=0;i<eles.length;i++){
	var ele=eles.item(i);
	new Drag(ele);//1、如果创建的实例没有赋值给一个变量，那这个实例存在嘛？
	//数据和变量的关系
	//2、当用new运算符去创建一个类的实例的时候，发生了那几件事？
		//第一步：先创建一个属于这个类的实例，并且把这个实例返回
		//第二点：这个实例已经就会有一些初始的属性了，比如说有__proto__属性，就是说实例上已经有原型方法了。
		//第三点：以这个实例为上下文，自动运行构造函数
		//类名有两个身份，一个身份是类，一个身份是自动运行函数（构造函数是用来初始化实例的）
}

3,"abcd",true,[1,2,3];
//
</script>
