<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>标准版订阅发布模式</title>
</head>
<body>

</body>
<script>
    function EventEmitter() {}//同EventTarget实现原理相同
    EventEmitter.prototype.on = function (type, fn) {//负责绑定
        if (!this["aEmitter" + type]) {
            this["aEmitter" + type] = [];
        }
        var a = this["aEmitter" + type];
        for (var i = 0; i < a.length; i++) {
            if (a[i] == fn)return;
        }
        a.push(fn);

    }
    EventEmitter.prototype.fire = function (type, e) {//负责执行
        var a = this["aEmitter" + type];
        if (a && a.length) {
            for (var i = 0; i < a.length; i++) {
                if (typeof a[i] == "function") {
                    a[i].call(this, e);
                } else {
                    a.splice(i, 1);
                    i--;
                }
            }
        }
    }
    EventEmitter.prototype.off = function (type, fn) {//负责移除
        var a = this["aEmitter" + type];
        if (a && a.length) {
            for (var i = 0; i < a.length; i++) {
                if (a[i] == fn) {
                    a[i] = null;
                    break;
                }
            }
        }

    }


    function Kettle(){};

    Kettle.prototype=new EventEmitter();//这样的继承方式不鞥写在定义原型方法之后
   // Kettle.prototype.__proto__=EventEmitter.prototype;//这是一种更安全的原型继承方式，它不会破坏Kettle类上原有的prototype，但是这种方式ie不支持

    Kettle.prototype.boiling=function(){
        console.log("开始烧水");
        var that=this;
        window.setTimeout(function(){
            console.log("水已经烧开");
            that.fire("boiling");
        },6000);
    }

    var k1=new Kettle();
    k1.on("boiling",drink);
    k1.on("boiling",noodles);
    k1.on("boiling",shower);
    k1.boiling();

    function drink(){
        console.log("喝点热水");
    }
    function noodles(){
        console.log("泡方便面");
    }
    function shower(){
        console.log("冲个热水澡");
    }



</script>
</html>