<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style type="text/css">
div{ width:100px; height:100px; position:absolute; top:0; left:0; cursor:move; -webkit-user-select:none; overflow:hidden; background:gray;}
div img{ width:100px; height:100px; border:none;}
</style>
</head>

<body>
<div id="div1"><img src="img/6.png"></div>
<div id="div2" style="top:100px; left:100px; background:orange;"><img src="img/7.png"></div>
<div id="div3" style="left:200px; background:purple"><img src="img/12.png"></div>
<div id="div4" style="left:400px; background:pink;"><img src="img/13.png"</div>
</body>
</html>
<script>
//1、解决DOM二级事件的绑定方法的不同的这个问题
	//IE里用attachEvent,标准浏览器用addEventListener，现在统一都用bind来绑定事件，用unbind来移除事件
//2、绑定到事件上的方法，在事件触发运行的时候，this要指向被绑定的元素。
	//解决this关键字最核心的一句代码是：ele.attachEvent("on"+type,function(){fn.call(ele)})。
	//但是这样只能解决绑定的问题，移除fn的时候，则会出现问题

//通过这个两个方法，逐渐培养思想：跨作用域考虑代码的写法（在一个方法里写的代码， 是为了另一外一个方法能够工作）

/*
 bind方法：负责完成DOM2级事件的绑定
 三个参数：ele被绑定事件的元素，type是事件类型，fn是绑定在事件上的方法


*/

/*
	解决绑定到事件上的方法的执行顺序问题的
	IE中无法解决顺序问题，我们把IE的事件机制推翻，然后重写一套机制，来解决这个问题
	这是半个“订阅-发布”模式
	
on方法----负责约定、订阅、绑定----->把方法先保存到一个程序池（事件池）里
run方法---通知机制------>去事件已经准备好的那个程序池里，遍历执行保存在里面的那些方法
off方法

*/

function on(ele,type,fn){//负责挖程序池，并且把需要绑定的方法保存到程序池里
	if(ele.addEventListener){
		ele.addEventListener(type,fn,false);
		return ;
	}
	
	//以下是IE的解决方案
	if(!ele["aEvent"+type]){
		ele["aEvent"+type]=[];
	}
	var a=ele["aEvent"+type];
	for(var i=0;i<a.length;i++){
		if(a[i]==fn)return;	
	}
	a.push(fn);
	//bind(ele,type,run);//触发run的执行的代码.
	//不再使用bind方法来解决被绑定的方法的this关键字的指向问题
	//把run绑定在相对应的事件上，并且run运行的时候，run的this指向ele
	ele.attachEvent("on"+type,function(){run.call(ele)});
}

function run(e){//负责找到对应的程序池，然后遍历执行这个数组里的所有的相关方法

	var e=e||window.event;
	var type=e.type;
	if(!e.target){
		e.target=e.srcElement;
		e.pageX=(document.documentElement.scrollLeft||document.body.scrollLeft)+e.clientX;
		e.pageY=(document.documentElement.scrollTop||document.body.scrollTop)+e.clientY;
		e.stopPropagation=function(){e.cancelBubble=true;}
		e.preventDefault=function(){e.returnValue=false;};	
	}
	var a=this["aEvent"+type];
	if(a&&a.length){
		for(var i=0;i<a.length;i++){
			if(typeof a[i]=="function"){
				a[i].call(this,e);//用call来执行a数组里的每个方法，是为了让数组里的方法在执行的时候，this指向被绑定的DOM元素
				
			}else{
				a.splice(i,1);
				i--;	
			}
		}
	}
}
function off(ele,type,fn){//负责把对应的方法从程序池里移除
	var a=ele["aEvent"+type];
	if(a&&a.length){
		for(var i=0;i<a.length;i++){
			if(a[i]==fn){
				a[i]=null;
				break;
			}	
		}
	}
}


function fn1(){alert(this.innerHTML+1)}
function fn2(){alert(this.innerHTML+2)}
function fn3(){alert(this.innerHTML+3)}
var ele=document.getElementById("div1");
on(ele,"click",fn1);
on(ele,"click",fn2);
on(ele,"click",fn3);
//fn1,fn2,fn3会各自被执行三

//ele上会有一个自定义属性叫aEventclick,这是个数组，这个数组里有三个方法：fn1,fn2,fn3

//当click事件触发的时候，run方法执行几次：3次
//run方法每执行一次，则去ele.aEventclick这个数组遍历执行里面保存的方法



</script>
