<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        div {

            width: 100px;
            height: 100px;
            position: absolute;
            top: 0;
            left: 0;
            cursor: move;
            -webkit-user-select: none;
        }

        div img {
            width: 100%;;
            height: 100%;
            border: none;
        }
    </style>
</head>
<body>
<div id="div1" style="top: 100px;left: 200px;background: purple"><img src="image123/1.png" alt=""></div>
<div id="div2" style="top: 200px;left: 200px;background: purple"><img src="image123/2.png" alt=""></div>
<div id="div3" style="top: 300px;left: 200px;background: purple"><img src="image123/3.jpg" alt=""></div>
<div id="div4" style="top: 400px;left: 200px;background: purple"><img src="image123/1.png" alt=""></div>
</body>
<script>
    var odiv = document.getElementById("div1");
    //1.ie里用attachEvent,标准浏览器用addEventListener，现在统一用bind来绑定事件，用unbind来移出事件
    //2.绑定到事件上的方法，在事件被触发运行的时候，this要指向被绑定的元素,解决this关键字是ele.attachEvent("on"+eventType,function(){fn.call(ele)});是最核心的代码，但是这样只能解决绑定的问题，但是移除的时候就不到这个匿名函数，注意，fn并没有直接绑定给事件
    //3.通过这个两个方法，逐渐培养思想，跨作用域考虑代码的写法（在一个方法里写的代码，是为了另一个方法能够工作）


    function on(ele, eventType, fn) {//负责挖程序池，并且把需要绑定的方法保存懂啊程序池中
        if (ele.addEventListener) {
            ele.addEventListener(eventType, fn, false);
            return;
        }
        //for ie8-
        if (!ele["aEvent" + eventType]) {
            //debugger;
            ele["aEvent" + eventType] = [];
            ele.attachEvent("on" + eventType, function (e) {
                run.call(ele);
            })

        };
        var a = ele["aEvent" + eventType];
        for (var i = 0; i < a.length; i++) {
            if (a[i] == fn) {
                return;
            }
        }
        a.push(fn);
        //用来触发run执行的代码,不再使用bind方法来解决被绑定的方法的this，关键字的指向问


    }

    function run() {//负责找到程序池，然后执行这个数组里的所有的相关方法
        var e = window.event;
        if (!e.target) {
            e.target = e.srcElement;
            e.pageX = (document.documentElement.scrollLeft || document.body.scrollLeft) + e.clientX;
            e.pageY = (document.documentElement.scrollTop || document.body.scrollTop) + e.clientY;
            e.stopPropagation = function () {
                e.cancelBubble = true;
            };
            e.preventDefault = function () {
                e.returnValue = false;
            }
        }

        var a = this["aEvent" + e.type];
        if (a && a.length) {
            for (var i = 0; i < a.length; i++) {
                if (typeof a[i] == "function") {
                    a[i].call(this, e);//如果不call,a[i],中的this是数组a,a[i]()等效于a.i();
                } else {
                    a.splice(i, 1);
                    i--;
                }

            }
        }

    }

    function off(ele, eventType, fn) {//负责对吧对应的方法重程序池里移除
        var a = ele["aEvent" + eventType];
        if (a && a.length) {
            for (var i = 0; i < a.length; i++) {
                if (a[i] == fn) {
                    a[i] = null;
                    break;
                }
            }
        }
    }
    function fn1() {
        console.log(1)
    }
    function fn2() {
        console.log(2)
    }
    function fn3() {
        console.log(3)
    }

    on(odiv,"click",fn1);
    on(odiv,"click",fn2);
    on(odiv,"click",fn3);
    console.log(odiv.myEventclick);
</script>
</html>