<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        ul {
            position: relative;
            width: 480px;
            height: 640px;
            margin: 100px auto;
            padding: 5px;
            list-style: none;
            background: #ccc;
        }

        ul li {
            float: left;
            width: 150px;
            height: 150px;
            margin: 5px;
            overflow: hidden;
            background: lightblue;
            cursor: move;
            -webkit-user-select: none;
            list-style: none;
        }

        li img {
            width: 150px;
            height: 150px;
            border: none;
            /*vertical-align: top;*/
        }
    </style>
</head>
<body>
<ul>
    <li><img src="img/1.png" alt=""></li>
    <li><img src="img/2.png" alt=""></li>
    <li><img src="img/3.png" alt=""></li>
    <li><img src="img/4.png" alt=""></li>
    <li><img src="img/5.png" alt=""></li>
    <li><img src="img/6.png" alt=""></li>
    <li><img src="img/7.png" alt=""></li>
    <li><img src="img/8.png" alt=""></li>
    <li><img src="img/9.png" alt=""></li>
    <li><img src="img/10.png" alt=""></li>
    <li><img src="img/11.png" alt=""></li>
    <li><img src="img/12.png" alt=""></li>
</ul>
</body>
<script src="js/utils20160916.js"></script>
<script src="js/drag_oop.js"></script>
<script src="js/animate2.js"></script>
<script src="js/event2.js"></script>
<script>
    var oLis = document.getElementsByTagName("li");
    for (var i = oLis.length - 1; i >= 0; i--) {
        oLis[i].style.left = (oLis[i].l = oLis[i].offsetLeft) + "px";
        oLis[i].style.top = (oLis[i].t = oLis[i].offsetTop) + "px";
        oLis[i].style.position = "absolute";//之所以会跑偏，是因为offsetLeft的值包括marginLeft（是从marginLeft里面算的）
        oLis[i].style.margin = 0;
        var b = new Drag(oLis[i]);
        b.on("start", increaseIndex);
       // b.on("end", goHome);
        b.on("moving", hitedTest);
        b.on("end",changePosition);
    }
    var zIndex = 0;
    function increaseIndex() {
        this.ele.style.zIndex = ++zIndex;
    }
    function goHome() {
        animate(this.ele, {left: this.ele.l, top: this.ele.t}, 1000, 3);

    }

    function isHited(a, b) {
        if((a.offsetLeft + a.offsetWidth < b.offsetLeft)||(a.offsetTop + a.offsetHeight < b.offsetTop)||(a.offsetLeft > b.offsetLeft + b.offsetWidth)|| (a.offsetTop > b.offsetTop + b.offsetHeight)) {
            return false;
        } else {
            return true;
        }
    }
    //进行碰撞检测，把撞上的保存到数组中，并且改变其背景色为红色，表示是撞上的
    function hitedTest() {
       // debugger;
        console.log(this);
        this.aHited = [];
        for (var i = 0; i < oLis.length; i++) {
            var oLi = oLis[i];
//            debugger;
            if (this.ele == oLi)continue;
            if (isHited(this.ele, oLi)) {
                //console.log(12);
                this.aHited.push(oLi);

                oLi.style.backgroundColor = "red";
            } else {
               // console.log(1234);

                oLi.style.backgroundColor = "";
            }
        }
    }

    function changePosition(){
        var c=this.aHited;
        if(c&& c.length){
            for(var i=0;i< c.length;i++){
                var oLi=c[i];
                oLi.distance=Math.sqrt(Math.pow(this.ele.offsetLeft-oLi.offsetLeft,2)+Math.pow(this.ele.offsetTop -oLi.offsetTop,2));

                oLi.style.backgroundColor="";
            }
            c.sort(function(a,b){
                return a.distance- b.distance;
            });

            var shortest=c[0];//找到最短元素就找到了
            animate(shortest,{left:this.ele.l,top:this.ele.t},700,4);
            animate(this.ele,{left:shortest.l,top:shortest.t},700,3);
            var l=this.ele.l;t=this.ele.t;
            this.ele.l=shortest.l;
            this.ele.t=shortest.t;
            shortest.t=t;
            shortest.l=l;
            this.ele.style.backgroundColor="purple";
            shortest.style.backgroundColor="aqua";
        }else{
            animate(this.ele, {left: this.ele.l, top: this.ele.t}, 1000, 3);
        }
    }

</script>
链式写法的基础是方法结束后返回实例；
</html>