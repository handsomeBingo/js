<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>拖拽基本</title>
    <style>
        *{
            margin:0;
            padding:0;
        }
        #box{
            width:100px;
            height: 100px;
            position: absolute;
            background: red;
        }
    </style>
</head>
<body>
<div id="box"></div>
</body>
<script charset="UTF-8">
    var oDiv=document.getElementById("box");
    function center(){
        var l=((document.documentElement.clientWidth||document.body.clientWidth)-oDiv.offsetWidth)/2;
        var t=((document.documentElement.clientHeight||document.body.clientHeight)-oDiv.offsetHeight)/2;
        oDiv.style.left=l+"px";
        oDiv.style.top=t+"px";
    }
    center();
    window.onresize=center;
    //1、先绑定onmousedown事件
    //2、在onmousedown事件中，绑定onmousemove和onmouseup
    //3、onmousemove中需要时时计算left和top并赋值回去，
    //4、onmouseup的时候选哟把onmousemove事件清空
    oDiv.onmousedown=function(e){
        e=e||window.event;
        this.setCapture? this.setCapture():void 0;//这个方法是让odiv和鼠标绑定在一起，但是这个方法在chrome中没有，火狐和ie都支持
        var x= e.clientX-this.offsetLeft;
        var y= e.clientY-this.offsetTop;
        this.x=x;
        this.y=y;
        document.onmousemove=function(e){
            e=e||window.event;
            //在拖拽的过程中，盒子的新位置，用鼠标的位置减去数遍相对于盒子的偏移量
            var l= e.clientX-oDiv.x;
            var t= e.clientY-oDiv.y;
            var minL=0;
            var minT=0;
            var maxL=(document.documentElement.clientWidth||document.body.clientHeight)-oDiv.offsetWidth;
            var maxT=(document.documentElement.clientHeight||document.body.clientHeight)-oDiv.offsetWidth;
            l= l<minL?minL:l>maxL?maxL:l;
            t= t<minT?minT:t>maxT?maxT:t;
            oDiv.style.left=l+"px";
            oDiv.style.top=t+"px";
        }
        document.onmouseup=function(){
            document.onmousemove=null;
            oDiv.releaseCapture?releaseCapture():null;
        }
    }




</script>
</html>